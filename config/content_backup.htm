<h1>About</h1>
<p>成員:張昱棠(41023153)，王翔楷(41023113)</p>
<p>倉儲:<a href="https://github.com/mdecd2023/2a-pj1ag14">https://github.com/mdecd2023/2a-pj1ag14</a> </p>
<p>網站:<a href="https://mdecd2023.github.io/2a-pj1ag14">https://mdecd2023.github.io/2a-pj1ag14</a>  </p>
<h1>w3</h1>
<p>w3 - 2023.03.10.16 已經完成分組網頁者, 可以得到分組網頁評分</p>
<p>w3 - 請各組寫一個程式判定 2a 哪一組已經完成網頁建置.</p>
<p>w3 開始執行<span> </span><a href="https://mde.tw/pjcopsim/content/bubbleRobTutorial.html">https://mde.tw/pjcopsim/content/bubbleRobTutorial.html</a></p>
<p></p>
<p>課程內容:創建以及了解如何共同維護團隊的倉儲</p>
<p>心得:在我們剛創建倉儲時不小心把倉儲Fork至我們個人的github倉儲下了，導致老師那邊的團隊倉儲連線不到我們更改的網站以及倉儲，再詢問老師時，老師以非常好理解的方式講解給我們理解，並讓我們理解了哪一步做錯了，老師也以引導的方式讓我們慢慢理解該如何解決，並告訴我們日後該如何與組員達到協同設計，</p>
<p></p>
<h2>張昱棠41023153心得</h2>
<p>張昱棠:由於上學期的usb隨身倉儲故障了，這學期用了一顆新的隨身碟，在一開始建立團隊倉儲acp時，發現新的隨身系統並未綁定github帳戶導致無法推送，綁定完後開始建立團隊的共同倉儲，發現我們共同倉儲由於不小心fork到我們的個人github下，導致無法連線至老師的團體倉儲後詢問老師問題，並且與組員及同學一起討論並且解決成功連線上。</p>
<p></p>
<p></p>
<h2>王翔楷41023113心得</h2>
<p>王翔楷:雖然先前在嚴老師的課上常常與同學共同討論課程內容<span>，這是首次要跟同學合作，建立共同倉儲，雖然剛開始弄得不是很順利，但最後藉著詢問老師，並且與同學共同討論後成功連上</span>。</p>
<h1>tutorial1</h1>
<p><a href="/downloads/BubbleRub tutorial presentation.pptx">ag14 tutorial presentation</a></p>
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/cmsimde/static" data-varname="winkVideoData_w2_1" height="600" muted="true" width="800"><source src="/downloads/bubbleRob1.mp4" type="video/mp4"/></video>
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/cmsimde/static" data-varname="winkVideoData_w2_1" height="600" muted="true" width="800"><source src="/downloads/bubbleRobfinal.mp4" type="video/mp4"/></video></div>
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/cmsimde/static" data-varname="winkVideoData_w2_1" height="600" muted="true" width="800"><source src="/downloads/Finish.mp4" type="video/mp4"/></video></div>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/h21ydWL7ZG8" title="YouTube video player" width="560"></iframe>
<p><a href="/downloads/bubbleRob.ttt">bubbleRob本體</a></p>
<p><a href="/downloads/slider.ttt">slider</a></p>
<p><a href="/downloads/wheels.ttt">wheels</a></p>
<p></p>
<p></p>
</div>
<div id="gtx-trans" style="position: absolute; left: -82px; top: 72.075px;">
<div class="gtx-trans-icon"></div>
</div>
<h2>心得</h2>
<p></p>
<p>張昱棠:</p>
<p>我們在製作過程中遇到了相當多的問題，光語言的部分我們就開了一個翻譯的網頁在旁邊一起配著原文版看，在一開始時，有點不太理解調整數值是必須輸入註解內的數值還是本文內的，導致數值有些輸入錯誤，在一連串的錯誤後，我們果斷選擇，直接開一個新檔案重做，由於當天我們留在學校做，大概從七點開始一路錯誤重來錯誤重來到快凌晨一點才回家，終於在隔天成功做出結果來了，在學習coppeliasim 的部分，接續上學期學到的在這學期應用，並且學習了許多新的知識</p>
<p><span>王翔楷:</span></p>
<p><span><span class="ui-provider yg b c d e f g h i j k l m n o p q r s t u v w x y z ab ac ae af ag ah ai aj ak" dir="ltr">製作初期其實並不順利，我們這組和另外兩個同學一起從七點弄到凌晨一點才回家，過程中最難克服的是對軟體的不熟悉，隔天利用下午沒課的時間慢慢摸索，最後才順利完成建置，再利用晚上上課的時間向老師請教感測器內部程式的問題後回到座位上研究，最後才順利完成功課。</span></span></p>
<p><span></span></p>
<h2>問題</h2>
<p>1.<span style="background-color: #ffff00;"><strong>coppeliasim中的scene與model有何不同?</strong></span></p>
<p>在CoppeliaSim中，Scene是一個包含多個物理仿真模型和其他環境元素（例如燈光、相機、傳感器等）的虛擬環境。這些模型可以是機器人、機械臂、傳送帶、機場跑道等等。 Scene通常用於仿真應用程序的開發和測試。而Model是CoppeliaSim中的一個概念，是一種可以單獨保存的物理仿真模型，可以將其作為場景中的組成部分進行導入和編輯。 Model包含一個或多個物體，例如一個機器人、一個傳感器、一個關節等等。 Model可以在場景中多次使用，也可以在不同場景之間共享。簡而言之，Scene是包含多個物理仿真模型和其他環境元素的虛擬環境，而Model是可以單獨保存的物理仿真模型，可以在不同場景中共享使用。</p>
<p>整理:</p>
<p><span style="color: #0000ff;">Scene:是一個包含多個物理仿真模型和其他環境元素（例如燈光、相機、傳感器等）的虛擬環境，Scene通常用於仿真應用程序的開發和測試</span><br/><span style="color: #0000ff;">model:是一種可以單獨保存的物理仿真模型，可以將其作為場景中的組成部分進行導入和編輯，可以在不同場景中共享使用。</span></p>
<p></p>
<p>2.<span style="background-color: #ffff00;"><strong>在CoppeliaSim scene中，何謂clean model?</strong></span></p>
<p>在CoppeliaSim中，"clean model" 通常指的是優化模型的過程，通過這個過程可以減少模型中無用的物件和多餘的細節，從而提高模擬的效率。</p>
<p>具體來說，進行模型優化可以通過以下步驟完成：</p>
<ol>
<li>
<p>刪除多餘的物體：在模型中刪除一些不必要的物體或場景，這些物體可能是你在建模時添加的一些細節，但對整個模型的性能並沒有太大的貢獻。</p>
</li>
<li>
<p>合併網格：網格是模型中的一些基本元素，當模型中存在過多的網格時，模型的渲染和運行速度就會變慢。因此，可以將一些相似的網格合併在一起，從而減少網格的數量。</p>
</li>
<li>
<p>簡化細節：當模型中存在過多的細節時，會使模擬變得非常緩慢。因此，可以將一些不必要的細節簡化或者刪除，從而提高模擬的效率。</p>
</li>
</ol>
<p><span style="color: #0000ff;">簡單來說，通過進行模型優化可以使CoppeliaSim的運行速度更快，從而更加有效地進行模擬和測試。</span></p>
<p>3.<span style="background-color: #ffff00;"><strong>如何在CoppeliaSim中，利用Lua以及Python建立primitive type object，並利用程式設定物件位置?</strong></span></p>
<p>以下是Lua語言範例:</p>
<p>-- 創建立方體並設定位置<br/>cubeHandle = sim.createPureShape(1, 3, {0.1, 0.1, 0.1}, 0.1)<br/>sim.setObjectPosition(cubeHandle, -1, {0, 0, 0.5})</p>
<p>以下python語言範例:</p>
<p># 導入sim模塊<br/>import sim</p>
<p># 創建立方體並設定位置<br/>cubeHandle = sim.simCreatePureShape(1, 3, [0.1, 0.1, 0.1], 0.1)<br/>sim.simSetObjectPosition(cubeHandle, -1, [0, 0, 0.5])</p>
<p>4.<span style="background-color: #ffff00;"><strong>CoppeliaSim.ttt檔案格式與.simscene.xml檔案格式有何不同?</strong></span></p>
<p>CoppeliaSim中的場景文件有兩種格式：.ttt和.simscene.xml。這兩種格式的主要區別在於它們的內容和用途不同。</p>
<p>.ttt格式是CoppeliaSim自有的文件格式，它是一個二進制文件，包含了所有場景、對象和設置的信息。這種格式可以通過CoppeliaSim的GUI界面直接打開和編輯，也可以通過Lua腳本編程方式創建、編輯和保存。.ttt格式具有以下特點：</p>
<ul>
<li>包含完整的場景、對象和設置的信息；</li>
<li>可以包含Lua腳本代碼和編程接口；</li>
<li>支持多種版本的CoppeliaSim；</li>
<li>不能通過文本編輯器直接查看和編輯。</li>
</ul>
<p>.simscene.xml格式則是一種通用的XML文件格式，其中包含了CoppeliaSim場景的描述信息。這種格式可以通過文本編輯器或者其他XML編輯器進行編輯，也可以通過Python等腳本語言讀取和編輯。.simscene.xml格式具有以下特點：</p>
<ul>
<li>是一種通用的XML文件格式；</li>
<li>可以通過文本編輯器或者其他XML編輯器進行編輯；</li>
<li>不包含Lua腳本代碼和編程接口；</li>
<li>可以被其他模擬軟件讀取和使用。</li>
</ul>
<p>總的來說，.ttt格式更適合在CoppeliaSim中進行場景的創建和編輯，而.simscene.xml格式則更適合與其他軟件進行數據交換和共享。</p>
<h2>程式講解</h2>
<p><img alt="" height="195" src="/images/螢幕擷取畫面 2023-03-19 181214.png" width="1215"/>首先這是一個Lua語言，在CoppeliaSim仿真環境中運行。該腳本定義了兩個函數：<strong>sysCall_init</strong>和<strong>sysCall_vision</strong>。</p>
<p>sysCall_init函數是仿真環境初始化時自動調用的函數，該函數目前是空的，即不執行任何操作。</p>
<p>sysCall_vision函數是CoppeliaSim的視覺模組塊（Vision Module）在每次運行時會調用的函數，該函數的作用是對視覺傳感器的圖像進行邊緣檢測（edge detection）。具體來說，函數中的三個函數調用分別為：</p>
<ul>
<li><strong>simVision.sensorImgToWorkImg(inData.handle)</strong>：將視覺傳感器的圖像複製到工作圖像中；</li>
<li><strong>simVision.edgeDetectionOnWorkImg(inData.handle,0.2)</strong>：對工作圖像進行邊緣檢測，檢測閾值為0.2；</li>
<li><strong>simVision.workImgToSensorImg(inData.handle)</strong>：將處理後的工作圖像複製回視覺傳感器的圖像緩衝區中。</li>
</ul>
<p>其中，inData是一個包含了視覺模組塊的一些信息的table對象，例如handle（視覺傳感器的句柄）等。simVision是CoppeliaSim中提供的用於處理視覺相關任務的庫。</p>
<p></p>
<p><img alt="" height="995" src="/images/FireShot Capture 008 - pjcopsim - mde.tw.jpg" width="1097"/></p>
<p><span style="color: #3366ff;">function</span> <strong>speedChange_callback(ui,id,newVal)</strong><br/><strong> speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100</strong><br/><span style="color: #3366ff;">end</span></p>
<p><span>這個函數會在使用者調整了速度控制UI元素後被呼叫。它接收3個參數：</span><code>ui</code><span>，這是UI元素的句柄；</span><code>id</code><span>，這是UI元素的ID；</span><code>newVal</code><span>，這是UI元素的新值。函數會根據新值計算出一個速度值</span><code>speed</code><span>。</span></p>
<p><span><span style="color: #3366ff;">function</span> <strong>sysCall_init()</strong><br/></span></p>
<p><span>這個函數是模擬程式的初始化函數，它只會被執行一次，當模擬程式啟動時。這個函數主要是執行一些初始化設置，例如設置模型的基礎物體、感測器和控制器，以及創建一些繪圖對象和UI元素。</span></p>
<p><span><strong>bubbleRobBase=sim.getObject('.')</strong><br/></span></p>
<p><span>這行代碼會獲取模型的根物體的句柄。在這個例子中，模型的根物體是代表機器人的物體。</span></p>
<p><span><strong>leftMotor=sim.getObject</strong>(<span style="color: #339966;">"./leftMotor"</span>)<br/><strong>rightMotor=sim.getObject</strong>(<span style="color: #339966;">"./rightMotor"</span>)<br/><strong>noseSensor=sim.getObject</strong>(<span style="color: #339966;">"./sensingNose"</span>)<br/></span></p>
<p><span>這些行會獲取左右馬達和前方感測器的句柄。這些句柄會在後續的代碼中用於控制馬達和讀取感測器。</span></p>
<p><span><strong>minMaxSpeed={50*math.pi/180,300*math.pi/180}</strong><br/></span></p>
<p>這行會定義最小和最大速度。在這個例子中，速度是以弧度每秒為單位表示的，最小速度為50度每秒，最大速度為300度每秒。</p>
<p><strong>backUntilTime=-1<br/></strong></p>
<p><span>這行代碼定義了一個變數</span><code>backUntilTime</code><span>，用於在後續的代碼中區分機器人是向前移動還是向後移動。</span></p>
<p><strong>robotCollection=sim.createCollection(0)</strong><br/><strong>sim.addItemToCollection(robotCollection,sim.handle_tree,bubbleRobBase,0)</strong></p>
<p><span>這些行代碼用於創建一個物體集合並將機器人物體添加到其中。這將使得感測器能夠檢測到機器人周圍的其他物</span></p>
<p><strong>function sysCall_actuation()：</strong></p>
<p>這個函數控制BubbleRob的行動。它首先讀取接近傳感器的數據，以檢測是否有東西在BubbleRob的前方。如果傳感器檢測到障礙物，則將backUntilTime設置為當前仿真時間加上4秒，表示BubbleRob現在處於倒車模式。否則，如果backUntilTime小於當前仿真時間，則BubbleRob處於前進模式，並且將左右馬達的目標速度設置為speed。否則，BubbleRob處於倒車模式，並且左右馬達的目標速度設置為一定的值，以實現向後行駛的效果。</p>
<p><strong>function sysCall_cleanup()：</strong></p>
<p><span>這個函數在仿真結束時被調用，以清理代碼中使用的任何資源。在這個例子中，它摧毀了UI對象，以避免內存洩漏。</span></p>